# Impossible, mauvaise dimension
M/M
#
M+2*M
#
M-M
# Soustraie la matrice
#3
data<-data.frame(M)
colnames(data)<-c("V1","V2","V3")
rownames(data)<-c("A","B","C","D")
#4
MoyCol<-colMeans(data)
VarCol<-colMeans(data^2)-colMeans(data)^2
etCol<-sqrt(VarCol)
#sd fait l'ecart type corrige = standart deviasion
#5
n<-nrow(data)
n
datac<-data-(matrix(rep(MoyCol,4),byrow = T, nrow = n))
datac
#Matrice qui a etait centree
datacr<-datac/((c(1,1,1,1))%*%t(etCol))
datacr
#Matrice centre reduit, reduit quand on a soustrait l'ecart type.
datacr2<-scale(data,center=T,scale=T)
datacr2
datacr3<-scale(data,center = T,scale=etCol)
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
M2
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
solve(P)
det(M2)
det(P)
n
data<-data.frame(M)
data
colnames(data)<-c("V1","V2","V3")
rownames(data)<-c("A","B","C","D")
data
nrow(data)
data.frame(M2)
Data<-data.frame(M2)
nrow(Data)
n
N
N<-nrow(Data)
N
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
MoyCol
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Data
Datac
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Datac
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
M<-matrix(c(1,1,2,0,0,2,2,0,0,0,2,2),ncol = 3,)
#2
colSums(M)
# Fait la somme des colonnes
t(M)
# Transpose la matrice
M*M
#Multiplication terme a terme
M*t(M)
# Ne peut pas se faire car la taille ne correspond pas
M%*%t(M)
# Multiplie les matrices entre elles, on entour * par % pour avoir une multiplication
# matriciel
M%*%M
# Impossible, mauvaise dimension
M/M
#
M+2*M
#
M-M
# Soustraie la matrice
#3
data<-data.frame(M)
colnames(data)<-c("V1","V2","V3")
rownames(data)<-c("A","B","C","D")
#4
MoyCol<-colMeans(data)
VarCol<-colMeans(data^2)-colMeans(data)^2
etCol<-sqrt(VarCol)
#sd fait l'ecart type corrige = standart deviasion
#5
n<-nrow(data)
n
datac<-data-(matrix(rep(MoyCol,4),byrow = T, nrow = n))
datac
#Matrice qui a etait centree
datacr<-datac/((c(1,1,1,1))%*%t(etCol))
datacr
#Matrice centre reduit, reduit quand on a soustrait l'ecart type.
datacr2<-scale(data,center=T,scale=T)
datacr2
datacr3<-scale(data,center = T,scale=etCol)
datacr3
#6
cov(data)
cor(data)
cov(datacr)
3/4*cov(datacr)
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
3/4*cov(datacr)
3/4*cov(Datacr)
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
M<-matrix(c(1,1,2,0,0,2,2,0,0,0,2,2),ncol = 3,)
#2
colSums(M)
# Fait la somme des colonnes
t(M)
# Transpose la matrice
M*M
#Multiplication terme a terme
M*t(M)
# Ne peut pas se faire car la taille ne correspond pas
M%*%t(M)
# Multiplie les matrices entre elles, on entour * par % pour avoir une multiplication
# matriciel
M%*%M
# Impossible, mauvaise dimension
M/M
#
M+2*M
#
M-M
# Soustraie la matrice
#3
data<-data.frame(M)
colnames(data)<-c("V1","V2","V3")
rownames(data)<-c("A","B","C","D")
#4
MoyCol<-colMeans(data)
VarCol<-colMeans(data^2)-colMeans(data)^2
etCol<-sqrt(VarCol)
#sd fait l'ecart type corrige = standart deviasion
#5
n<-nrow(data)
n
datac<-data-(matrix(rep(MoyCol,4),byrow = T, nrow = n))
datac
#Matrice qui a etait centree
datacr<-datac/((c(1,1,1,1))%*%t(etCol))
datacr
#Matrice centre reduit, reduit quand on a soustrait l'ecart type.
datacr2<-scale(data,center=T,scale=T)
datacr2
datacr3<-scale(data,center = T,scale=etCol)
datacr3
#6
cov(data)
cor(data)
cov(datacr)
3/4*cov(datacr)
#vrai matrice des covariance, matrice des corelation,
#3/4 car (n - 1) / n
#Elles ne sont pas pareille car c'est aussi des valeurs corrige.
#7
Mcor<-3/4*cov(datacr)
Mcor
eigen(Mcor)
#9
P<-eigen(Mcor)$vectors
P
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
3/4*cov(Datacr)
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
eigen(Mcor)$values
det(eigen(Mcor)$values)
det(eigen(Mcor)$vectors)
P<-eigen(Mcor)$vectors
det(P)
solve(P)%*%P
t(P)%*%P
vp<-eigen(Mcor)$values
IneRel<-vp/sum(vp)
vp
IneRel
t(P)%*%P
P*vp*P-1
solve(P)%*%P
P-1<-solve(P)%*%P
P-1<-solve(P)%*%P
P-1 <-solve(P)%*%P
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
3/4*cov(Datacr)
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P-1<-solve(P)%*%P
P1<-solve(P)%*%P
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
trans<-t(P)%*%P
P*vp*P1
t(M2)
M2
vp
P
solve(P)
P*colSums(P)*P1
Datacr
3/4*cov(Datacr)
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
M2
eigen(Mcor)
P1<-solve(P)
P
P1
vp
Mcor
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
trans<-t(P)%*%P
P**P1
diag(M2)
diag(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
diag(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5))
diag(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
diag(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4, nrow = 4)
DM2<-diag(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4, nrow = 4)
P*DM2*P1
P
P1
DM2
P%*%DM2%*%P1
diag(eigen(m)$values)
diag(eigen(M2)$values)
d<-diag(eigen(M2)$values)
P%*%d%*%P1
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
eigen(M2)
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
d<-diag(eigen(M2)$values)
P%*%d%*%P1
d<-diag(eigen(Mcor)$values)
P%*%d%*%P1
d<-diag(eigen(M2)$values)
P%*%d%*%P1
P%*%d%*%P1
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,5),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
d<-diag(eigen(M2)$values)
P%*%d%*%P1
Datacr<-Datac/((c(1,1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
d<-diag(eigen(M2)$values)
P%*%d%*%P1
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,nrow = 4)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,5),byrow = T, nrow = N))
Datac
#matrice centree
Datacr<-Datac/((c(1,1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
d<-diag(eigen(M2)$values)
P%*%d%*%P1
Data
MoyCol
Datac
Datacr<-Datac/((c(1,1,1,1))%*%(etCol))
Datacr
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
d<-diag(eigen(M2)$values)
P%*%d%*%P1
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
d<-diag(eigen(M2)$values)
P%*%d%*%P1
M2<-matrix(c(5,2,1,0,2,5,0,-1,1,0,5,-2,0,-1,-2,5),ncol = 4,nrow = 4)
M2
Data<-data.frame(M2)
N<-nrow(Data)
MoyCol<-colMeans(Data)
VarCol<-colMeans(Data^2)-colMeans(Data)^2
etCol<-sqrt(VarCol)
Datac<-Data-(matrix(rep(MoyCol,4),byrow = T, nrow = N))
#matrice centree
Datacr<-Datac/((c(1,1,1,1))%*%t(etCol))
Datacr
#matrice centree reduite
Mcor<-3/4*cov(Datacr)
Mcor
eigen(Mcor)
vp<-eigen(Mcor)$values
#Les valeurs propres sont donc donnee par le vecteurs vp
P<-eigen(Mcor)$vectors
det(P)
P1<-solve(P)
#On note les valeurs avec une tres forte puissance (-16 et -17) qui sont donc tres
#proche de 0
d<-diag(eigen(M2)$values)
P%*%d%*%P1
Sol<-matrix(c(5,-6,5,12)nrow = 4,ncol=1)
Sol<-matrix(c(5,-6,5,12)nrow = 4,ncol=1))
Sol<-matrix(c(5,-6,5,12)nrow = 4,ncol=1)
Sol<-matrix(c(5,-6,5,12),nrow = 4,ncol=1)
Sol
Sol%*%M2
M2%*%Sol
setwd("~/Documents/Cours/L2/Semestre 2 /Logiciel R/TP3")
resACP<-PCA(data)
resACP
PCA(cidre.txt)
PCA(Data)
library("cidre.txt", lib.loc="/Users/schmitt/Documents/Cours/L2/Semestre 2 /Logiciel R/TP3")
read.table("cidre.txt",header = T,sep = ",")
read.table("cidre.txt",header = T,sep = ";")
cidre<-read.table("cidre.txt",header = T,sep = ";")
cidre
View(cidre)
PCA(cidre)
pcauchy(cidre)
PCA(cidre)
library("FactoMineR", lib.loc="/Library/Frameworks/R.framework/Versions/3.2/Resources/library")
PCA(cidre)
resACP$ind$coord
ACP$ind$coord
ACP$ind$coord
ACP$ind$cos2
ACP(cidre)$ind$cos2
PCA(cidre)$ind$cos2
PCA(cidre)
PCA$ind$contrib(cidre)
$ind$contrib(cidre)
ind$contrib(cidre)
PCA$ind$contrib(cidre)
setwd(/Users/schmitt/Documents/Cours/L2/Semestre 2 /Logiciel R/TP3)
setwd("/Users/schmitt/Documents/Cours/L2/Semestre 2 /Logiciel R/TP3")
cidre<-write.table("cidre.txt",header = T,sep = ";")
cidre<-write.table("cidre.txt",header = F,sep = ";")
cidre<-write.table("cidre.txt",sep = ";")
cidre
cidre<-read.table("cidre.txt",header= T ,sep = ";")
print(cidre)
PCA$ind$contrib(cidre)
PCA(cidre)
PCA(cidre)"$var$contrib"
PCA(cidre)$var$contrib
PCA(cidre)$ind$coord
PCA(cidre)eigen
PCA(cidre)$eig
round(ACP$ind$coord[,c(1,2)],digits = 3)
round(PCA$ind$coord[,c(1,2)],digits = 3)
round(PCA(cidre)$ind$coord[,c(1,2)],digits = 3)
write.table(round(PCA(cidre)$ind$coord[,c(1,2)],digits = 3),(round(PCA(cidre)$eig[,c(1,2)],digits = 3)
write.table(round(PCA(cidre)$ind$coord[,c(1,2)],digits = 3)),(round(PCA(cidre)$eig[,c(1,2)],digits = 3)
